---
layout: default
title: Week 3
parent: CS 지식
nav_order: 3
---

# 3주차 (네트워크 & 운영체제) 
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---

# 지현님 -> 나
{: .label .label-red }

## 동기와 비동기식 프로그래밍의 차이점은?

일반적으로 `동기와 비동기의 차이점`은  
메소드를 실행시킴과 동시에 반환 값이 기대되는 경우를 `동기`라고 표현한다.  
그렇지 않은 경우를 `비동기`라고 표현한다.  

`동시`에 라는 말은 실행되었을 때 값이 반환되기 전까지는 `blocking` 되어 있다는 것을 의미한다.  
`비동기`의 경우, `blocking` 되지 않고 `이벤트 큐`에 넣거나 `백그라운드 스레드`에게 해당 `task를 위임`하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.  

`동기식 프로그래밍`은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때 까지 아무것도 못하고 대기해야 한다. 즉 `속도가 느리다.`  
`비동기식 프로그래밍`은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다.  

[관련 링크](https://private.tistory.com/24){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 운영체제에서 요구 페이징에 대해 설명해주세요.

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 `물리 메모리`에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 `요구 페이징`이라 하며, `가상 메모리 시스템`에서 많이 사용된다.  
그리고 `가상 메모리`는 대게 `페이지`로 관리된다.  

`요구 페이징`을 사용하는 `가상메모리`에서는 실행과정에서 필요해질 때 `페이지`들이 적재된다.  

한번도 접근되지 않은 `페이지`는 `물리 메모리`에 적재되지 않는다.  

프로세스 내의 개별 `페이지`들은 `페이저`에 의해 관리된다.  
`페이저`는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.  

[관련 링크](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 라우터와 스위치의 차이점은?

`라우터`와 `스위치`는 모두 컴퓨터 네트워크의 장치를 상호 연결하는 데 사용되는 네트워킹 장치이지만 라우터는 스위치보다 고급이며 지능적입니다.  
`라우터`는 네트워크 계층에서 작동하며 스위치는 데이터 링크 계층에서 작동합니다.  
`라우터`는 라우팅 알고리즘으로 알려진 복잡한 알고리즘을 사용하므로 더 많은 처리 능력을 필요로 한다.    

`스위치`는 간단한 자체 학습 메커니즘을 사용하여 라우터보다 비용이 더 적다.    
`스위치`는 `근거리 통신망`에서만 사용됩니다.  

그러나 `라우터`는 `근거리 통신망`과 `광역 네트워크`에서 모두 사용됩니다.  

#### 스위치  
`같은 네트워크 내부`에서 데이터 전송을 수행하는 기기 스위치는 `패킷`이 수신되면 스위치의 메모리에 패킷을 저장하고 목적지 `MAC주소`를 분석하고 `스위치 테이블`을 사용하여 올바른 `포트`를 찾은 다음, 올바른 포트로 `패킷`을 전달한다.  

#### 라우터  
`네트워크 사이`에 데이터 전송을 수행하는 기기 네트워크를 통해 데이터 패킷을 라우팅 하는 네트워킹 장치이다.  

`라우터`는 특정 목적지 IP에 도달하기 위해 패킷을 라우팅 해야 하는 게이트웨이 IP로 구성된 `라우팅 테이블`이라고 하는 테이블을 유지 관리한다.  
`라우터`가 패킷을 받으면 먼저 라우터 메모리에 패킷을 저장하고 패킷의 대상 IP 주소를 분석합니다.  
그런 다음 라우팅 테이블을 조회하여 패킷을 라우팅해야하는 게이트웨이를 확인합니다.  
그런 다음 해당 정보를 기반으로 패킷을 적절하게 전달합니다.  

---

## TCP에서 3 way handshaking이랑, 각 과정과 상태에 대해서 설명해주세요.

![](/assets/images/cs/week3.png)  

```markdown
현재 상태 - 서버에 열려있는 포트는 Listen 상태, 클라이언트는 close 상태  
```  

클라이언트에서 서버로 연결 요청을 하기 위해 `SYN 데이터`를 보냄.  
서버에서 해당 포트는 Server에서 해당 포트는 `LISTEN 상태`에서 `SYN 데이터`를 받고 `SYN_RCV`로 상태가 변경된다.  
그리고 요청을 정상적으로 받았다는 `대답(ACK)`와 Client도 포트를 열어달라는 `SYN` 을 같이 보낸다.  
Client에서는 `SYN+ACK` 를 받고 `ESTABLISHED`로 상태를 변경하고 서버에 요청을 잘 받았다는 `ACK` 를 전송한다.  
`ACK`를 받은 서버는 상태가 `ESTABLSHED`로 변경된다.  
간단하게 이야기하면, SYN은 연결 요청, ACK는 OK이다.  

처음에 클라이언트에서 연결 요청을 하면, 서버에서 연결하자라는 내용을 연결 요청하고, 이에 맞추어 받았다는 응답을 클라이언트가 주는 것.  
`SYN`랑 `ACK`는 `TCP 세그먼트 필드` 안에 `control bit` 또는 `flag bit`로 정의 되어 있다.  

[관련 링크1](https://manducku.tistory.com/46?category=688828){: .btn .fs-5 .mb-4 .mb-md-0 }
[관련 링크2](https://websecurity.tistory.com/93){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

### (꼬리질문) 그렇다면 서버로부터 ACK 패킷을 받지 못한다면 클라이언트는 어떻게 동작하는가?  
먼저 SYN을 보낸 후 제한 시간을 설정한 후, 제한 시간 안에 서버로부터 ACK패킷을 받지 못한다면 다시 SYN을 보낸다.

---

## OSI 7계층에서 네트워크 계층과 전송 계층이 하는 역할을 각각 설명 해주세요.

`네트워크 계층` : 송신측에서 수신측까지 데이터를 안전하게 전달하기 위해서 논리적 링크를 설정하고 상위 계층 데이터를 작은 패킷으로 분할하여 전송하는 역할을 수행한다.  
데이터를 목적지까지 가장 안전하고 빠르게 전달하도록 한다. - 라우팅 기능  
  
`전송 계층` : 전송 단위는 segment를 사용하며 주소는 port를 사용한다.  
발신지 대 목적지(end-to-end)간 제어와 에러를 담당한다.  
즉, 신뢰성 있는 전송을 담당한다고 할 수 있다.  
End-to-end 전송은 단순히 한 컴퓨터에서 다음 컴퓨터로의 전달이 아니라 송신 컴퓨터의 응용프로그램(프로세스)에서 최종 수신 컴퓨터의 응용 프로그램(프로세스) 으로의 전달을 의미한다.  

c
---

# 병준님 -> 성용이
{: .label .label-yellow }

## 페이지 교체 정책에 대해 생각나는 것 모두 말해주세요.

1. `OPT(optimal)`  
이론적으로만 존재하는 최적의 페이지 교체 알고리즘으로, 가장 먼 미래에 사용될 페이지를 교체하는 정책.  
성능을 비교하기 위한 척도로 사용  

2. `NRU(Not Recently Used)`  
최근에 사용된 페이지를 유지하는 것을 선호하는 알고리즘.  
referenced, modified를 운영체제가 계산하여 4개의 클래스로 나눈 뒤 활용  

3. `FIFO(First in First out)`  

먼저 들어온 페이지를 먼저 내보내는 정책.  
가장 적은 오버헤드를 가짐.  

4. `second-chance`  
FIFO와 비슷하나, page out 하기 전에 referenced bit가 set 되어있으면 큐에 다시 집어넣음.  
모든 page의 referenced bit가 set 되어 있으면 가장 먼저 page out 요청되었던 페이지가 page out 당함  

5. `LRU(Least Recently Used)`  
최근에 가장 적게 사용된 페이지를 교체.  
NRU와 비슷.  
차이점은 LRU는 페이지에 대한 참조를 긴 시간 유지하지만, NRU는 clock 타임만 유지  

6. `Random`  

7. `NFU(Not Frequently Used)`  
가장 적게 사용된 페이지를 교체.  
각각에 대한 페이지에 counter를 사용하여 참조된 횟수를 계산 후, 가장 적은 횟수의 페이지를 page out하는 방법  

[관련 링크](https://en.wikipedia.org/wiki/Page_replacement_algorithm){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## TCP와 UDP의 차이를 말해주세요.

```markdown
UDP 같은 경우에는 비 연결형이랑  
TCP는 연결형이라고 볼 수 있는데 3wayhs 라고해서  
만들때 연결을 확정하고나서 정보를 송수신 할 수 있게 만들어 사용  
UDP는 멀티미디어 전송에 사용.
```

`신뢰성` : TCP는 메시지 수신을 확인하지만, UDP에서는 알 수 없다.  
`순서 정렬` : TCP는 메시지가 보내진 순서를 보장하기 위해 재조립하지만, UDP는 메시지 도착 순서를 알 수 없다.  
`부하` : UDP가 TCP보다 더 빠르다.  

---

## 프로그램 메모리의 구조와 각각의 역할을 설명해주세요.

1. `코드영역(code segment, text segment)`  
실행할 프로그램의 코드가 저장된 영역.  
read-only / excutable  

2. `데이터 영역`  
전역변수, 정적 변수가 할당되는 공간.  
프로그램 종료시 소멸  

3. `힙 영역`  
동적으로 할당/해제되는 영역  
낮은주소 -> 높은 주소로 할당  
런타임시 크기가 결정됨  

4. `스택 영역`  
지역변수와 매개변수  
높은주소 -> 낮은 주소로 할당  
컴파일시 크기가 결정됨  

[관련 링크1](https://en.wikipedia.org/wiki/Data_segment){: .btn .fs-5 .mb-4 .mb-md-0 }
[관련 링크2](https://github.com/jobhope/TechnicalNote/blob/master/operating_system/MemoryStructure.md){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## IP 주소와 Port에 대해 설명해주세요.
`ip address` :  인터넷규약주소는 컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해서 사용하는 특수한 번호이다.  

`port` : 운영체제 통신의 종단점으로, 네트워크 서비스나 특정 프로세스를 식별하는 논리 단위  

[관련 링크1](https://ko.wikipedia.org/wiki/IP_%EC%A3%BC%EC%86%8C){: .btn .fs-5 .mb-4 .mb-md-0 }
[관련 링크2](https://ko.wikipedia.org/wiki/%ED%8F%AC%ED%8A%B8_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9)){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 메모리 단편화의 종류에 대해 설명해주세요.
`내부 단편화` : 프로세스의 크기가 페이지보다 작은 경우  

`외부 단편화` : 여유 공간이 여러 조각으로 나뉘는 현상.  
조각이 너무 작게 나있어 응용프로그램의 성능을 뒷바쳐주지 못함  

[관련 링크](https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94){: .btn .fs-5 .mb-4 .mb-md-0 }

---

# 나 -> 지현님
{: .label .label-green }

## 멀티 스레드 vs 멀티 프로세스

| 종류        | 장점                     | 단점                      |
|:-----------|:------------------------|:------------------------|
| 멀티 프로세스  | 하나의 프로세스가 죽더라도 다른 프로세스에게는 영향을 끼치지 않고 정상적으로 수행된다. | 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지한다. |
| 멀티 스레드   | 멀티 프로세스 보다 적은 메모리 공간을 차지하고 문맥전환이 빠르다.                | 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다. |  

이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다.  

따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.  

---

## 캐시 메모리와 캐시 L1 L2 차이

![](/assets/images/cs/week3_2.png)  
![](/assets/images/cs/week3_3.png)  


`캐시 메모리`란, 속도가 빠른 장치와 느린 장치 사이에서 속도차에 따른 `병목 현상`을 줄이기 위한 `범용 메모리`를 지칭한다.  
CPU에서는 CPU 코어(고속)와 메모리(CPU에 비해 저속) 사이에서 속도차에 따른 `병목 현상`을 `완화`하는 역할을 한다.  

CPU에는 이러한 캐시 메모리가 2~3개 정도 사용된다.  
이를 L1,L2,L3 캐시 메모리라 하며, 여기서 L은 ‘Level’을 의미한다.  
이는 속도와 크기에 따라 분류한 것으로, `L1 캐시`는 일반적으로 CPU칩안에 내장되어 데이터 사용/참조에 가장 먼저 사용된다.  
`L1캐시`는 보통 8~64KB 정도의 용량으로 CPU가 가장 빠르게 접근하게 되며, 여기서 데이터를 찾지 못하면, 이제 `L2캐시` 메모리로 넘어간다.  
 
`L2캐시` 메모리는 용도와 역할은 L1캐시와 비슷하지만 속도는 그보다 느리다.  
일반적으로 64KB~4MB정도 사용된다.  
`L2캐시`는 CPU회로 판에 별도의 칩으로 내장된다.  

앞서 말한대로 `L1캐시`를 먼저 뒤지고, `L2캐시`를 뒤져 데이터를 찾는다.  
역시 `L2 캐시`는 `L1캐시`보다 느리지만, 일반 메모리(RAM)보다는 빠르다.  

`L3캐시` 메모리도 동일한 원리로 작동한다.  
웬만한 프로세서에서는 `L3캐시` 메모리를 달고있지 않다.  
`L2캐시`로 충분히 커버할 수 있기 때문이다.  
intel core2 duo나 quad에는 `L3캐시`가 없지만, 코어 i7에는 8MB를 달아뒀다.  
`L1/L2캐시` 메모리 정도만 CPU 성능에 직접적인 영향을 미치기에 `L3캐시`는 크게 신경쓰지 않는것이 일반적인 추세다.  
`L3캐시`는 CPU가 아닌 메인보드에 내장되는 경우가 더 많다.  

[관련 링크](https://12bme.tistory.com/402){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

