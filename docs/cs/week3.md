---
layout: default
title: Week 3
parent: CS 지식
nav_order: 3
---

# 3주차 (네트워크 & 운영체제) 
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---

# 지현님 -> 나
{: .label .label-red }

## 동기와 비동기식 프로그래밍의 차이점은?

일반적으로 `동기와 비동기의 차이점`은  
메소드를 실행시킴과 동시에 반환 값이 기대되는 경우를 `동기`라고 표현한다.  
그렇지 않은 경우를 `비동기`라고 표현한다.  

`동시`에 라는 말은 실행되었을 때 값이 반환되기 전까지는 `blocking` 되어 있다는 것을 의미한다.  
`비동기`의 경우, `blocking` 되지 않고 `이벤트 큐`에 넣거나 `백그라운드 스레드`에게 해당 `task를 위임`하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.  

`동기식 프로그래밍`은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때 까지 아무것도 못하고 대기해야 한다. 즉 `속도가 느리다.`  
`비동기식 프로그래밍`은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다.  

[관련 링크](https://private.tistory.com/24){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 운영체제에서 요구 페이징에 대해 설명해주세요.

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 `물리 메모리`에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 `요구 페이징`이라 하며, `가상 메모리 시스템`에서 많이 사용된다.  
그리고 `가상 메모리`는 대게 `페이지`로 관리된다.  

`요구 페이징`을 사용하는 `가상메모리`에서는 실행과정에서 필요해질 때 `페이지`들이 적재된다.  

한번도 접근되지 않은 `페이지`는 `물리 메모리`에 적재되지 않는다.  

프로세스 내의 개별 `페이지`들은 `페이저`에 의해 관리된다.  
`페이저`는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.  

[관련 링크](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 라우터와 스위치의 차이점은?

`라우터`와 `스위치`는 모두 컴퓨터 네트워크의 장치를 상호 연결하는 데 사용되는 네트워킹 장치이지만 라우터는 스위치보다 고급이며 지능적입니다.  
`라우터`는 네트워크 계층에서 작동하며 스위치는 데이터 링크 계층에서 작동합니다.  
`라우터`는 라우팅 알고리즘으로 알려진 복잡한 알고리즘을 사용하므로 더 많은 처리 능력을 필요로 한다.    

`스위치`는 간단한 자체 학습 메커니즘을 사용하여 라우터보다 비용이 더 적다.    
`스위치`는 `근거리 통신망`에서만 사용됩니다.  

그러나 `라우터`는 `근거리 통신망`과 `광역 네트워크`에서 모두 사용됩니다.  

#### 스위치  
`같은 네트워크 내부`에서 데이터 전송을 수행하는 기기 스위치는 `패킷`이 수신되면 스위치의 메모리에 패킷을 저장하고 목적지 `MAC주소`를 분석하고 `스위치 테이블`을 사용하여 올바른 `포트`를 찾은 다음, 올바른 포트로 `패킷`을 전달한다.  

#### 라우터  
`네트워크 사이`에 데이터 전송을 수행하는 기기 네트워크를 통해 데이터 패킷을 라우팅 하는 네트워킹 장치이다.  

`라우터`는 특정 목적지 IP에 도달하기 위해 패킷을 라우팅 해야 하는 게이트웨이 IP로 구성된 `라우팅 테이블`이라고 하는 테이블을 유지 관리한다.  
`라우터`가 패킷을 받으면 먼저 라우터 메모리에 패킷을 저장하고 패킷의 대상 IP 주소를 분석합니다.  
그런 다음 라우팅 테이블을 조회하여 패킷을 라우팅해야하는 게이트웨이를 확인합니다.  
그런 다음 해당 정보를 기반으로 패킷을 적절하게 전달합니다.  

---

## TCP에서 3 way handshaking이랑, 각 과정과 상태에 대해서 설명해주세요.

![](/assets/images/cs/week3.png)  

```markdown
현재 상태 - 서버에 열려있는 포트는 Listen 상태, 클라이언트는 close 상태  
```  

클라이언트에서 서버로 연결 요청을 하기 위해 `SYN 데이터`를 보냄.  
서버에서 해당 포트는 Server에서 해당 포트는 `LISTEN 상태`에서 `SYN 데이터`를 받고 `SYN_RCV`로 상태가 변경된다.  
그리고 요청을 정상적으로 받았다는 `대답(ACK)`와 Client도 포트를 열어달라는 `SYN` 을 같이 보낸다.  
Client에서는 `SYN+ACK` 를 받고 `ESTABLISHED`로 상태를 변경하고 서버에 요청을 잘 받았다는 `ACK` 를 전송한다.  
`ACK`를 받은 서버는 상태가 `ESTABLSHED`로 변경된다.  
간단하게 이야기하면, SYN은 연결 요청, ACK는 OK이다.  

처음에 클라이언트에서 연결 요청을 하면, 서버에서 연결하자라는 내용을 연결 요청하고, 이에 맞추어 받았다는 응답을 클라이언트가 주는 것.  
`SYN`랑 `ACK`는 `TCP 세그먼트 필드` 안에 `control bit` 또는 `flag bit`로 정의 되어 있다.  

[관련 링크1](https://manducku.tistory.com/46?category=688828){: .btn .fs-5 .mb-4 .mb-md-0 }
[관련 링크2](https://websecurity.tistory.com/93){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

### (꼬리질문) 그렇다면 서버로부터 ACK 패킷을 받지 못한다면 클라이언트는 어떻게 동작하는가?  
먼저 SYN을 보낸 후 제한 시간을 설정한 후, 제한 시간 안에 서버로부터 ACK패킷을 받지 못한다면 다시 SYN을 보낸다.

---

## OSI 7계층에서 네트워크 계층과 전송 계층이 하는 역할을 각각 설명 해주세요.

네트워크 계층 : 송신측에서 수신측까지 데이터를 안전하게 전달하기 위해서 논리적 링크를 설정하고 상위 계층 데이터를 작은 패킷으로 분할하여 전송하는 역할을 수행한다.  
데이터를 목적지까지 가장 안전하고 빠르게 전달하도록 한다. - 라우팅 기능  
  
전송 계층 : 전송 단위는 segment를 사용하며 주소는 port를 사용한다.  
발신지 대 목적지(end-to-end)간 제어와 에러를 담당한다.  
즉 신뢰성 있는 전송을 담당한다고 할 수 있다.  
End-to-end 전송은 단순히 한 컴퓨터에서 다음 컴퓨터로의 전달이 아니라 송신 컴퓨터의 응용프로그램(프로세스)에서 최종 수신 컴퓨터의 응용 프로그램(프로세스) 으로의 전달을 의미한다.  

[관련 링크](https://goitgo.tistory.com/25){: .btn .fs-5 .mb-4 .mb-md-0 }  

---


# 병준님 -> 성용이
{: .label .label-yellow }