---
layout: default
title: Week 3
parent: CS 지식
nav_order: 3
---

# 3주차 (네트워크 & 운영체제) 
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---

# 지현님 -> 나
{: .label .label-red }

## 동기와 비동기식 프로그래밍의 차이점은?

```markdown
나 : 음...
단일 프로세스나 단일 스레드 같은 경우는...
동기식이라 볼 수 있는데 그게 빠르다는 장점이 있고 일을 나눠서 하는게 아니라 단일로 하기 때문에 
그 임계영역이라는게 없고

비동기는 여러 다중 프로세스나 다중 스레드 방식인데 한 임계구역을 가지고 사용하기 때문에 
디버깅도 해야되고 신경쓸게 많다고 생각합니다.
```  

```markdown
질문자 : 동기적 프로그래밍과 비동기적 프로그래밍에 대해 어떻게 생각하세요?

병준님 : 어 일단
동기적 프로그래밍이랑 비동기적 프로그래망 차이를 말씀드리는게 목적인거죠?

다중프로세스 환경이나 다중 스레드 환경에서 공유되는 데이터가 수정될 때 문제가 될 수 있어요.
그래서 예를 들면 싱글 코어나 싱글 프로세스나 싱글 스레드 같은 경우에는 
그런 공유에 대한 걱정을 하지 않아도 되기 때문에 훨씬 더 빠른 속도로 이용할 수 있는 장점은 있어요.

대신에 다중프로세스 같은 경우에는 더 유기적인 처리가 가능하고 대신 디버깅이 조금 더 어려워 질 수 있고요 
그래서 상황에 맞게 사용하는 게 맞고 뭐가 옳고 그르다가 없다고 생각합니다.
```  

일반적으로 `동기와 비동기의 차이점`은  
메소드를 실행시킴과 동시에 반환 값이 기대되는 경우를 `동기`라고 표현한다.  
그렇지 않은 경우를 `비동기`라고 표현한다.  

`동시`에 라는 말은 실행되었을 때 값이 반환되기 전까지는 `blocking` 되어 있다는 것을 의미한다.  
`비동기`의 경우, `blocking` 되지 않고 `이벤트 큐`에 넣거나 `백그라운드 스레드`에게 해당 `task를 위임`하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.  

`동기식 프로그래밍`은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때 까지 아무것도 못하고 대기해야 한다. 즉 `속도가 느리다.`  
`비동기식 프로그래밍`은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다.  

[관련 링크](https://private.tistory.com/24){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 운영체제에서 요구 페이징에 대해 설명해주세요.

```markdown
나: 메모리에 이제 스케줄링을 통해서 메모리에 올라가게 되는데 메모리에 효율적으로 로드시키기 위해서 
단편화 문제점을 줄이기 위해서 paging기법을 쓰는걸로 알고 있습니다.
```  

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 `물리 메모리`에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 `요구 페이징`이라 하며, `가상 메모리 시스템`에서 많이 사용된다.  
그리고 `가상 메모리`는 대게 `페이지`로 관리된다.  

`요구 페이징`을 사용하는 `가상메모리`에서는 실행과정에서 필요해질 때 `페이지`들이 적재된다.  

한번도 접근되지 않은 `페이지`는 `물리 메모리`에 적재되지 않는다.  

프로세스 내의 개별 `페이지`들은 `페이저`에 의해 관리된다.  
`페이저`는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.  

[관련 링크](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 라우터와 스위치의 차이점은?

`라우터`와 `스위치`는 모두 컴퓨터 네트워크의 장치를 상호 연결하는 데 사용되는 네트워킹 장치이지만 라우터는 스위치보다 고급이며 지능적입니다.  
`라우터`는 네트워크 계층에서 작동하며 스위치는 데이터 링크 계층에서 작동합니다.  
`라우터`는 라우팅 알고리즘으로 알려진 복잡한 알고리즘을 사용하므로 더 많은 처리 능력을 필요로 한다.    

`스위치`는 간단한 자체 학습 메커니즘을 사용하여 라우터보다 비용이 더 적다.    
`스위치`는 `근거리 통신망`에서만 사용됩니다.  

그러나 `라우터`는 `근거리 통신망`과 `광역 네트워크`에서 모두 사용됩니다.  

#### 스위치  
`같은 네트워크 내부`에서 데이터 전송을 수행하는 기기 스위치는 `패킷`이 수신되면 스위치의 메모리에 패킷을 저장하고 목적지 `MAC주소`를 분석하고 `스위치 테이블`을 사용하여 올바른 `포트`를 찾은 다음, 올바른 포트로 `패킷`을 전달한다.  

#### 라우터  
`네트워크 사이`에 데이터 전송을 수행하는 기기 네트워크를 통해 데이터 패킷을 라우팅 하는 네트워킹 장치이다.  

`라우터`는 특정 목적지 IP에 도달하기 위해 패킷을 라우팅 해야 하는 게이트웨이 IP로 구성된 `라우팅 테이블`이라고 하는 테이블을 유지 관리한다.  
`라우터`가 패킷을 받으면 먼저 라우터 메모리에 패킷을 저장하고 패킷의 대상 IP 주소를 분석합니다.  
그런 다음 라우팅 테이블을 조회하여 패킷을 라우팅해야하는 게이트웨이를 확인합니다.  
그런 다음 해당 정보를 기반으로 패킷을 적절하게 전달합니다.  

---

## TCP에서 3 way handshaking이랑, 각 과정과 상태에 대해서 설명해주세요.

![](/assets/images/cs/week3.png)  

```markdown
현재 상태 - 서버에 열려있는 포트는 Listen 상태, 클라이언트는 close 상태  
```  

클라이언트에서 서버로 연결 요청을 하기 위해 `SYN 데이터`를 보냄.  
서버에서 해당 포트는 Server에서 해당 포트는 `LISTEN 상태`에서 `SYN 데이터`를 받고 `SYN_RCV`로 상태가 변경된다.  
그리고 요청을 정상적으로 받았다는 `대답(ACK)`와 Client도 포트를 열어달라는 `SYN` 을 같이 보낸다.  
Client에서는 `SYN+ACK` 를 받고 `ESTABLISHED`로 상태를 변경하고 서버에 요청을 잘 받았다는 `ACK` 를 전송한다.  
`ACK`를 받은 서버는 상태가 `ESTABLSHED`로 변경된다.  
간단하게 이야기하면, SYN은 연결 요청, ACK는 OK이다.  

처음에 클라이언트에서 연결 요청을 하면, 서버에서 연결하자라는 내용을 연결 요청하고, 이에 맞추어 받았다는 응답을 클라이언트가 주는 것.  
`SYN`랑 `ACK`는 `TCP 세그먼트 필드` 안에 `control bit` 또는 `flag bit`로 정의 되어 있다.  

[관련 링크1](https://manducku.tistory.com/46?category=688828){: .btn .fs-5 .mb-4 .mb-md-0 }
[관련 링크2](https://websecurity.tistory.com/93){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

### (꼬리질문) 그렇다면 서버로부터 ACK 패킷을 받지 못한다면 클라이언트는 어떻게 동작하는가?  
먼저 SYN을 보낸 후 제한 시간을 설정한 후, 제한 시간 안에 서버로부터 ACK패킷을 받지 못한다면 다시 SYN을 보낸다.

---

## OSI 7계층에서 네트워크 계층과 전송 계층이 하는 역할을 각각 설명 해주세요.

`네트워크 계층` : 송신측에서 수신측까지 데이터를 안전하게 전달하기 위해서 논리적 링크를 설정하고 상위 계층 데이터를 작은 패킷으로 분할하여 전송하는 역할을 수행한다.  
데이터를 목적지까지 가장 안전하고 빠르게 전달하도록 한다. - 라우팅 기능  
  
`전송 계층` : 전송 단위는 segment를 사용하며 주소는 port를 사용한다.  
발신지 대 목적지(end-to-end)간 제어와 에러를 담당한다.  
즉, 신뢰성 있는 전송을 담당한다고 할 수 있다.  
End-to-end 전송은 단순히 한 컴퓨터에서 다음 컴퓨터로의 전달이 아니라 송신 컴퓨터의 응용프로그램(프로세스)에서 최종 수신 컴퓨터의 응용 프로그램(프로세스) 으로의 전달을 의미한다.  

---

# 병준님 -> 성용이
{: .label .label-yellow }

## 페이지 교체 정책에 대해 생각나는 것 모두 말해주세요.

1. `OPT(optimal)`  
이론적으로만 존재하는 최적의 페이지 교체 알고리즘으로, 가장 먼 미래에 사용될 페이지를 교체하는 정책.  
성능을 비교하기 위한 척도로 사용  

2. `NRU(Not Recently Used)`  
최근에 사용된 페이지를 유지하는 것을 선호하는 알고리즘.  
referenced, modified를 운영체제가 계산하여 4개의 클래스로 나눈 뒤 활용  

3. `FIFO(First in First out)`  

먼저 들어온 페이지를 먼저 내보내는 정책.  
가장 적은 오버헤드를 가짐.  

4. `second-chance`  
FIFO와 비슷하나, page out 하기 전에 referenced bit가 set 되어있으면 큐에 다시 집어넣음.  
모든 page의 referenced bit가 set 되어 있으면 가장 먼저 page out 요청되었던 페이지가 page out 당함  

5. `LRU(Least Recently Used)`  
최근에 가장 적게 사용된 페이지를 교체.  
NRU와 비슷.  
차이점은 LRU는 페이지에 대한 참조를 긴 시간 유지하지만, NRU는 clock 타임만 유지  

6. `Random`  

7. `NFU(Not Frequently Used)`  
가장 적게 사용된 페이지를 교체.  
각각에 대한 페이지에 counter를 사용하여 참조된 횟수를 계산 후, 가장 적은 횟수의 페이지를 page out하는 방법  

[관련 링크](https://en.wikipedia.org/wiki/Page_replacement_algorithm){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## TCP와 UDP의 차이를 말해주세요.

```markdown
성용: UDP 같은 경우에는 비 연결형이랑 
TCP는 연결형이라고 볼 수 있는데 3wayhands 라고해서
만들때 연결을 확정하고나서 정보를 송수신 할 수 있게 만들어 사용
UDP는 멀티미디어 전송에 사용.
```  

`신뢰성` : TCP는 메시지 수신을 확인하지만, UDP에서는 알 수 없다.  
`순서 정렬` : TCP는 메시지가 보내진 순서를 보장하기 위해 재조립하지만, UDP는 메시지 도착 순서를 알 수 없다.  
`부하` : UDP가 TCP보다 더 빠르다.  

---

## 프로그램 메모리의 구조와 각각의 역할을 설명해주세요.

1. `코드영역(code segment, text segment)`  
실행할 프로그램의 코드가 저장된 영역.  
read-only / excutable  

2. `데이터 영역`  
전역변수, 정적 변수가 할당되는 공간.  
프로그램 종료시 소멸  

3. `힙 영역`  
동적으로 할당/해제되는 영역  
낮은주소 -> 높은 주소로 할당  
런타임시 크기가 결정됨  

4. `스택 영역`  
지역변수와 매개변수  
높은주소 -> 낮은 주소로 할당  
컴파일시 크기가 결정됨  

[관련 링크1](https://en.wikipedia.org/wiki/Data_segment){: .btn .fs-5 .mb-4 .mb-md-0 }
[관련 링크2](https://github.com/jobhope/TechnicalNote/blob/master/operating_system/MemoryStructure.md){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## IP 주소와 Port에 대해 설명해주세요.

```markdown
성용: IP 주소의 경우는 인터넷 프로토콜로 버전 4,6가 있습니다.
6가 나온 이유는 주소값이 이미 더 많이 필요하기 때문에 나오게 됐습니다.
port의 경우에는 각 포트의 영역에 따라서 그 프로토콜을 달리하여 
저희가 원하는 통신을 할 수 있도록 하는 것으로만 알고 있습니다.

AQ. IP주소와 port번호를 어떻게 적는가? 123을 앞에 두고 
그 뒤에 콜론과 함께 포트 번호를 적는 것으로 알고 있습니다.
```  

`ip address` :  인터넷규약주소는 컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해서 사용하는 특수한 번호이다.  

`port` : 운영체제 통신의 종단점으로, 네트워크 서비스나 특정 프로세스를 식별하는 논리 단위  

[관련 링크1](https://ko.wikipedia.org/wiki/IP_%EC%A3%BC%EC%86%8C){: .btn .fs-5 .mb-4 .mb-md-0 }
[관련 링크2](https://ko.wikipedia.org/wiki/%ED%8F%AC%ED%8A%B8_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9)){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 메모리 단편화의 종류에 대해 설명해주세요.
`내부 단편화` : 프로세스의 크기가 페이지보다 작은 경우  

`외부 단편화` : 여유 공간이 여러 조각으로 나뉘는 현상.  
조각이 너무 작게 나있어 응용프로그램의 성능을 뒷바쳐주지 못함  

[관련 링크](https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94){: .btn .fs-5 .mb-4 .mb-md-0 }

---

# 나 -> 지현님
{: .label .label-green }

## 멀티 스레드 vs 멀티 프로세스

```markdown
멀티 프로세스 장점으로는 한 프로세스 작업이 다른 프로세스 작업에 영향을 끼치지 않는다는 장점이 있습니다.

멀티 스레드는 메모리를 공유하기 때문에 Context Switching에 비용이 많이 들지만 
그래도 스레드끼리 통신을 할때 메모리를 공유하기 때문에 편하다는 장점이 있습니다.

반면에 프로세스는 Context Swithching 할때 PCB를 교체 해줘야하기 때문에 비용이 많이 들고 
프로세스들 끼리 통신을 할 때 InterProcess Communication을 이용해야하기 때문에
성능이 낮다는 특징이 있습니다.

그럼에도 불구하고 멀티 스레드는 통신과 이제 메모리와 공유한다는 특징이 있지만
메모리를 공유하기 때문에 thread safe하게 동기화를 맞춰줘야한다는 특징이 있습니다.
```

| 종류        | 장점                     | 단점                      |
|:-----------|:------------------------|:------------------------|
| 멀티 프로세스  | 하나의 프로세스가 죽더라도 다른 프로세스에게는 영향을 끼치지 않고 정상적으로 수행된다. | 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지한다. |
| 멀티 스레드   | 멀티 프로세스 보다 적은 메모리 공간을 차지하고 문맥전환이 빠르다.                | 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다. |  

이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다.  

따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.  

---

### InterProcess Communication의 종류 아는 것을 말해보시오. 

---

## 캐시 메모리와 캐시 L1 L2 차이

![](/assets/images/cs/week3_2.png)  
![](/assets/images/cs/week3_3.png)  


`캐시 메모리`란, 속도가 빠른 장치와 느린 장치 사이에서 속도차에 따른 `병목 현상`을 줄이기 위한 `범용 메모리`를 지칭한다.  
CPU에서는 CPU 코어(고속)와 메모리(CPU에 비해 저속) 사이에서 속도차에 따른 `병목 현상`을 `완화`하는 역할을 한다.  

CPU에는 이러한 캐시 메모리가 2~3개 정도 사용된다.  
이를 L1,L2,L3 캐시 메모리라 하며, 여기서 L은 ‘Level’을 의미한다.  
이는 속도와 크기에 따라 분류한 것으로, `L1 캐시`는 일반적으로 CPU칩안에 내장되어 데이터 사용/참조에 가장 먼저 사용된다.  
`L1캐시`는 보통 8~64KB 정도의 용량으로 CPU가 가장 빠르게 접근하게 되며, 여기서 데이터를 찾지 못하면, 이제 `L2캐시` 메모리로 넘어간다.  
 
`L2캐시` 메모리는 용도와 역할은 L1캐시와 비슷하지만 속도는 그보다 느리다.  
일반적으로 64KB~4MB정도 사용된다.  
`L2캐시`는 CPU회로 판에 별도의 칩으로 내장된다.  

앞서 말한대로 `L1캐시`를 먼저 뒤지고, `L2캐시`를 뒤져 데이터를 찾는다.  
역시 `L2 캐시`는 `L1캐시`보다 느리지만, 일반 메모리(RAM)보다는 빠르다.  

`L3캐시` 메모리도 동일한 원리로 작동한다.  
웬만한 프로세서에서는 `L3캐시` 메모리를 달고있지 않다.  
`L2캐시`로 충분히 커버할 수 있기 때문이다.  
intel core2 duo나 quad에는 `L3캐시`가 없지만, 코어 i7에는 8MB를 달아뒀다.  
`L1/L2캐시` 메모리 정도만 CPU 성능에 직접적인 영향을 미치기에 `L3캐시`는 크게 신경쓰지 않는것이 일반적인 추세다.  
`L3캐시`는 CPU가 아닌 메인보드에 내장되는 경우가 더 많다.  

[관련 링크](https://12bme.tistory.com/402){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## Round Robin에서 time quantum(할당 시간)을 너무 작게 줬을 때와 너무 크게 주었을 때 어떻게 될지 설명하시오.

설정한 time quantum이 너무 커지면 FCFS와 같아진다.  

또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다.  

그렇기 때문에 적당한 time quantum을 설정하는 것이 중요하다.  

---

## REST API에 대해 설명하시오

REST는 ‘Representation State Transfer’의 약어로 하나의 URI는 하나의 고유한 리소스(Resource)를 대표하도록 설계된다는 개념에 전송방식을 결합해서 원하는 작업을 지정합니다.  

```markdown
ex) ‘/board/123’은 게시물 중에서 123번이라는 고유한 의미를 가지도록 설계하고, 
이에 대한 처리는 GET,POST방식과 같이 추가적인 정보를 통해서 결정합니다.  
```  

따라서 REST 방식은 다음과 같이 구성된다고 생각할 수 있습니다.  

```markdown
URI + GET/POST/PUT/DELETE/...  
```

---

## Cookie와 Session에 대해 설명하시오.

`COOKIE`  
웹 서버는 쿠키를 이용해서 웹 브라우저에 정보를 전송할 수 있다.  
웹 서버로부터 쿠키를 전달 받은 웹 브라우저는 이후 웹 서버에 요청을 보낼 때 쿠키를 함께 전송한다.  
이를 사용하면 웹 서버와 웹 브라우저는 필요한 값을 공유하고 상태를 유지할 수 있다.  

웹 브라우저가 보관하는 데이터이다.  
웹 브라우저는 웹 서버에 요청을 보낼 때 쿠키를 함께 전송하며, 웹 서버는 웹 브라우저가 전송한 쿠키를 사용해서 필요한 데이터를 읽을 수 있다.  

아이디를 평문 형태로 쿠키 값으로 사용하면 보안에 큰 문제가 생긴다.  
웹 브라우저는 자체적으로 개발도구를 제공하고 있는데 이 개발도구를 사용하면 쿠키 값을 쉽게 변경할 수 있기 때문에, 쿠키 값을 변경해서 서버에 전송할 수 있다.  
즉, 다른 아이디로 서버에 접근할 수 있게 되는 것이다.  
이런 이유로 쿠키에 아이디를 저장할 때에는 평문으로 저장하지 않고 다양한 암호화 방식을 혼합해서 저장한다.  

---

`SESSION`  
서버 세션을 사용하면 클라이언트의 상태를 저장할 수 있다.  
쿠키와 차이점은 세션은 웹 브라우저가 아니라 서버에 값을 저장한다는 점이다.  
서버는 세션을 사용해서 클라이언트 상태를 유지할 수 있기 때문에, 로그인한 사용자 정보를 유지하기 위한 목적으로 세션을 사용한다.  

---