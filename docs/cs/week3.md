---
layout: default
title: Week 3
parent: CS 지식
nav_order: 3
---

# 3주차 (네트워크 & 운영체제) 
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---

# 지현님 -> 나
{: .label .label-red }

## 동기와 비동기식 프로그래밍의 차이점은?

일반적으로 `동기와 비동기의 차이점`은  
메소드를 실행시킴과 동시에 반환 값이 기대되는 경우를 `동기`라고 표현한다.  
그렇지 않은 경우를 `비동기`라고 표현한다.  

`동시`에 라는 말은 실행되었을 때 값이 반환되기 전까지는 `blocking` 되어 있다는 것을 의미한다.  
`비동기`의 경우, `blocking` 되지 않고 `이벤트 큐`에 넣거나 `백그라운드 스레드`에게 해당 `task를 위임`하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.  

`동기식 프로그래밍`은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때 까지 아무것도 못하고 대기해야 한다. 즉 `속도가 느리다.`  
`비동기식 프로그래밍`은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다.  

[관련 링크](https://private.tistory.com/24){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 운영체제에서 요구 페이징에 대해 설명해주세요.

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 `물리 메모리`에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 `요구 페이징`이라 하며, `가상 메모리 시스템`에서 많이 사용된다.  
그리고 `가상 메모리`는 대게 `페이지`로 관리된다.  
`요구 페이징`을 사용하는 가상메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다.  
한번도 접근되지 않은 페이지는 `물리 메모리`에 적재되지 않는다.
프로세스 내의 개별 페이지들은 페이저에 의해 관리된다.  
페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다. 

[관련 링크](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS){: .btn .fs-5 .mb-4 .mb-md-0 }  


# 병준님 -> 성용이
{: .label .label-yellow }