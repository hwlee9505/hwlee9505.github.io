---
layout: default
title: Week 4
parent: CS 지식
nav_order: 4
---

# 4주차 (데이터베이스 & 자바 & 스프링) 
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---

# 지현님 -> 나
{: .label .label-red }

## 데이터베이스 상의 트랜잭션에 대해 설명하시오. 

데이터베이스 내에 하나의 그룹으로 처리해야 하는 명령문을 모아놓은 작업단위 또는 데이터 처리의 한 단위이다.  

1. 원자성 : 트랜잭션 과정들이 전부 반영되거나 혹은 완벽히 처리돼야 함 그렇지 않다면 전부 취소  

2. 일관성 : 트랜잭션의 실행이 성공적으로 끝나면 항상 일관성 있는 DB상태로 변환 항상 일관된 상태에서 트랜잭션이 수행된 후 또 다른 일관된 상태를 가지게된다. 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태를 갖지 않을 수 있다.  

3. 독립성 : 여러 가지 트랜잭션들이 동시에 실행되고 있을 때 실행중에는 다른 트랜잭션이 끼어들 수 없다. 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 한다. 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 한다. -> 트랜잭션 isolation level  

4. 지속성/영속성 : 트랜잭션이 성공적으로 완료되었다면 그 결과는 지속적으로 저장되어야 한다.  

---

### (꼬리질문)   동시성제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 때 생길 수 있는 문제는 무엇인가요?  
갱신 손실(lost update) : 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효가 되는 것  
오손 데이터 읽기(dirty read) : 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것 만약 그 완료되지 않은 트랜잭션이 rollback을 하는 경우 읽은 데이터는 소용이 없어진다. dirty read를 하는 경우 rollback이 연쇄적으로 일어날수 있다.  
반복할 수 없는 읽기(unrepeatable read) :  한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것  => 그 사이에  다른 트랜잭션이 update했다는 뜻  

![](/assets/images/cs/week4_2.png)  

---

## 자바의 클래스에서 serialVersionUID를 선언해야 하는 이유에 대해서 설명하시오.  

자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동하게 된다.  
하지만 객체는 바이트형이 아니기 때문에 스트림을 통해서 저장하거나 네트워크로 전송하는 것이 불가능하다.  
따라서 객체를 스트림으로 입출력하기 위해서 바이트배열로 변환하는 것을 직렬화라고 한다.  

JVM은 직렬화나 역직렬화를 하는 시점의 클래스에 대해 version 번호를 부여한다. 그런데 만약 이 시점에서 클래스의 정의가 바뀌게 된다면 version번호를 새롭게할당한다.  
직렬화와 역직렬화의 version번호가 서로 다르면 안되기 때문에 serialVersionUID를 선언해서 문제를 해결한다.  
즉 클래스 버전이 맞는지 확인하기 위한 용도이다.

---

## 서블릿에 데이터를 요청하는 메소드 2가지에 대해서 설명하시오.

`GET` : 서버에 있는 정보를 가져오기 위해 설계 됨.  
240바이트까지 전달 할 수 있음.  
POST 방식에 비해 속도가 빠름.   
검색엔진에서 검색단어 전송에 많이 이용함.  
URL노출로 보안성이 요구되는 경우엔 사용 할 수 없음.  

`POST` : 서버로 정보를 올리기 위해 설계 됨.  
URL에 파라미터가 표시 되지 않음.  
내부적으로 데이터가 이동함.  
GET 방식에 비해 속도 느림.  
데이터 크기 제한 없음.  

[관련 링크](https://k9e4h.tistory.com/75?category=554301){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## JSP에서 페이지 이동 방법에 대해 설명하시오.

`포워드` : request 스코프에 담긴값이 유효하다.  
(request, response가 유지된다.  
이동된 url이 화면에 안보인다.(사용자는 이동했는지 알 수 없음)  
- 포워드 하는 방법

`리다이렉트` : 클라이언트가 새로 페이지를 요청한 것과 같은 방식으로 페이지가 이동된다.  
requset,response가 유지되지 않는다.(새로 만들어진다)  
이동된 url이 화면에 보인다.  

[관련 링크](https://installed.tistory.com/entry/8-JSP-%ED%8A%B9%EC%A0%95%ED%8E%98%EC%9D%B4%EC%A7%80%EB%A1%9C-%EC%9D%B4%EB%8F%99%EB%B0%A9%EB%B2%95){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 데이터베이스에서 Index란 무엇일까요?

데이터베이스에서 원하는 데이터를 탐색할때, full scan을 타지 않도록 해서 검색 속도를 높여주는 자료구조입니다.  

장점은 테이블 검색과 정렬 속도가 향상되지만 단점으로는 DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에  새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다는 점이다.  

뿐만 아니라 인덱스 테이블을 별도로 생성해야 되기 때문에 디스크 용량을 소모한다는 단점이 있다.(DB의 10%정도)  

참고) 인덱스를 기본키로 자동설정해서 관리가 용이하게 한다고 한다.  
인덱스를 처음에 생성하는데에는 시간이 많이 소모된다.  
인덱스를 사용한다고 항상 효율적인 것은 아니다.  
사용하지 않는 인덱스는 삭제하는 것이 좋다.  

[관련 링크](https://itholic.github.io/database-index/){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

### (꼬리질문) DB index를 어떨 때에 사용하면 효과적인가요?

![](/assets/images/cs/week4_3.png)  

[관련 링크](https://blog.naver.com/bsww201/221906066898){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 스프링에서 annotation에 대해서 설명하시오.

`Annotation`
자바에서 어노테이션은 JDK1.5부터 제공되는 기능, @로 시작하는 주석의 한 형태를 말한다.  어노테이션은 메타데이터의 한 형태로, 프로그램에 대한 정보를 제공하지만 어노테이션을 설정한 코드에 직접적인 영향을 미치지 않는다.  
소스코드에 @어노테이션의 형태로 표현하며 클래스, 필드, 메소드의 선언부에 적용할 수 있는 특정기능이 부여된 표현법을 말합니다.  
애플리케이션 규모가 커질수록, xml 환경설정이 매우 복잡해지는데 이러한 어려움을 개선시키기 위해 자바 파일에 어노테이션을 적용해서 개발자가 설정 파일 작업을 할 때 발생시키는 오류를 최소화해주는 역할을 합니다.  
어노테이션 사용으로 소스 코드에 메타데이터를 보관할 수 있고, 컴파일 타임의 체크뿐 아니라 어노테이션 API를 사용해 코드 가독성도 높여줍니다.  

@Controller :  springmvc 사용시 controller에 등록  
@RequestMapping : 특정 메소드에서 요청되는 URL과 매칭시키는 어노테이션  
@Autowired : 자동으로 의존성 주입하기 위한 어노테이션  
@Service : 비즈니스 로직 처리하는 서비스 클래스에 등록  
@Repository : DAO에 등록  
@Component : xml설정 없이 자동으로 빈 등록  

[관련 링크](https://loco-motive.tistory.com/29){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

# 병준님 -> 성용
{: .label .label-yellow }

## database의 index란?

테이블에 대한 동작의 속도를 높여주는 자료구조.  

[관련 링크](https://ko.wikipedia.org/wiki/%EC%9D%B8%EB%8D%B1%EC%8A%A4_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 정규화가 무엇인지와 하는 이유는?  

정규화 : 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스  
목적 :  
1. 데이터베이스의 변경(갱신, 상십, 삭제)시 이상 현상 제거  
  - 삽입 이상 : 어떤 특정 사실은 전혀 기록되지 않는 경우(null 발생)  
  - 갱신 이상 : 일부는 변경되고 일부는 변경되지 않는 모순 상태가 발생할 수 있다.  
  - 삭제 이상 : 데이터의 삭제가 전혀 다른 사실에 대한 데이터의 삭제도 필요로 하는 경우  
2. DB 구조 확장시 재 디자인 최소화  
3. 사용자의 데이터 모델을 더욱 의미있게 : 현실세계의 개념과 관계를 반영  
4. 다양한 질의 지원  

[관련 링크](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## Commit과 Rollback이란?  

Commit : 트랜잭션에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산  
Rollback : 트랜잭션 처리가 비정상적으로 종료되었을 때, 모든 연산을 취소시키는 연산  

[관련 링크](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## 상속과 합성이 무엇인지, 그리고 차이는?  

상속 : is-a 관계(extends). 캡슐화 약화됨. 실행 시점에 코드가 유연하지 못함  
합성 : has-a 관계(field)  

[관련 링크](https://biggwang.github.io/2019/07/31/OOP/%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94%20%ED%95%A9%EC%84%B1%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%20%ED%95%98%EB%8A%94%20%EC%9D%B4%EC%9C%A0/){: .btn .fs-5 .mb-4 .mb-md-0 }  

---

## int 자료형에 Integer.MAX_VALUE에 1을 더하면?  

자바는 기초자료형에 대해 overflow를 따로 검출하지 않는다. 따라서 음수 중 가장 작은 값인 -Integer.MAX_VALUE - 1이 될 것이다.  

![](/assets/images/cs/week4.png)  

추가설명 : Integer.MAX_VALUE을 2의 보수로 나타내면  
01111111111111111....1111(32자리) 이다. 여기에 overflow가 나면  
10000000000000000....0000(32자리)가 되고, 이 값은 음수의 가장 작은 값이다.  

---

## sping의 의존성 주입이란?  

한 객체가 다른 객체를 참조하고 있는 것을 의존성을 가진다고 하는데, 이러한 의존성을 직접 관리하지 않고 framework에 위임하는 것을 말한다. 직접 의존성을 관리하면  
1) 긴밀한 결합(tight coupling)이 발생  
2) 하나의 모듈 변경에 따른 다른 모듈의 변경 수반  
3) unit test 어려워짐  
이라는 단점이 존재함. 

DI(Dependency Injection, 의존성 주입)는 IoC(Inversion Of Control, 제어의 역전)라고도 불림. IoC는 다음과 같은 특징을 가짐  
1) 개발자가 모든 것을 제어하지만, 코드 전체에 대한 제어는 framework가 함  
2) 개발자가 설정하면 container가 알아서 처리  

즉, 개발자는 framework 속에서 프로그래밍을 하는 것. DI를 통해 다음과 같은 이점을 얻을 수 있다.  
1) 중복성 감소  
2) 재사용성 증가  
3) 더 많은 테스트 코드 생성 가능  
4) 코드 읽기가 더 쉬워짐  

[관련 링크](https://gmlwjd9405.github.io/2018/11/09/dependency-injection.html){: .btn .fs-5 .mb-4 .mb-md-0 }  

